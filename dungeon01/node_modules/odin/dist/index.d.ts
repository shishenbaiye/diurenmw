declare module "odin" {
    /**
     * MapEx(可序列化)
     */
    export namespace MapEx {
        type MapExClass<T> = {
            [key: string | number]: T;
        };
        /**
         * 是否为空
         * @param map
         * @returns 是/否
         */
        function isNull<T>(map: MapExClass<T>): boolean;
        /**
         * 获取对象
         * @param map
         * @param key
         * @returns
         */
        function get<T>(map: MapExClass<T>, key: string | number): T;
        /**
         * 设置对象
         * @param map
         * @param key
         * @param val
         */
        function set<T>(map: MapExClass<T>, key: string | number, val: T): void;
        /**
         * 删除对象
         * @param map
         * @param key
         * @returns 成功/失败
         */
        function del<T>(map: MapExClass<T>, key: string | number): boolean;
        /**
         * 是否有指定对象
         * @param map
         * @param key
         * @returns
         */
        function has<T>(map: MapExClass<T>, key: string | number): boolean;
        /**
         * 获取count数量
         * @param map
         * @param key
         * @returns
         */
        function count<T>(map: MapExClass<T>): number;
        /**
         * 遍历map
         * @param map
         * @param callback
         */
        function forEach<T>(map: MapExClass<T>, callback: (key: string | number, element: T) => void): void;
        /**
         * 拷贝，Val还是引用出来的，只是Map换了
         * @param map
         * @returns
         */
        function copy<T>(map: MapExClass<T>): MapExClass<T>;
    }
}

declare module "odin" {
    /**
     * 战斗对象抽象接口
     */
    export interface IFightRole {
        /**
        * 是否死亡
        */
        isDead: boolean;
        /**
         * 死亡动画播放完成，死透了
         */
        onDeadComplete(): void;
        /**
         * 当前位置
         */
        location: mw.Vector;
        /**
         * 角色对象
         */
        character: mw.Character | mw.Character;
        /**
         * 被伤害
         * @param Attacker 攻击者
         * @param val 伤害值
         */
        onHurt(Attacker: IFightRole, val: number): void;
        /**
         * 移动到目的地
         * @param pos 目的地
         * @param radius 半径
         * @param callBack 移动完成回调
         */
        moveTo(pos: mw.Vector, radius: number, callBack: Function): void;
        /**
         * 停止移动
         */
        stopMove(): void;
        /**
         * 看向某个方向
         * @param pos 目标点
         */
        lookAt(pos: mw.Vector): any;
        /**
        * 是否在移动
        */
        isMoving(): boolean;
        /**
         * 获取一个可释放的技能
         */
        getSkill(): number;
        /**
         * 释放技能
         * @param target 目标
         * @param skill 技能id
         */
        releaseSkill(target: IFightRole, skill: number): void;
        /**
         * 最大可释放技能距离，寻路时候用
         */
        getMaxAttackDis(): number;
        /**
         * 最大追踪距离，超过了应该返回出生点
         */
        getMaxTrackDis(): number;
        /**
         * 检测当前对象是否合法可攻击
         */
        checkTargetValid(target: IFightRole): boolean;
        /**
         * 清除当前对象
         * @param target 和当前对象对比，一样的才清除
         */
        clearCurTarget(target: IFightRole): void;
        /**
         * 找一个对象
         */
        findATarget(): IFightRole;
        /**
         * 设置当前对象
         * @param target 目标对象
         */
        setCurTarget(target: IFightRole): void;
        /**
         * 当前锁定的对象
         */
        getCurTarget(): IFightRole;
        /**
         * 返回出生点的位置
         */
        getBack2Pos(): mw.Vector;
        /**
         * 找目标的视野
         */
        getEyeDis(): number;
        /**
         * 战斗实体类型，用来区分玩家，怪物等
         */
        getType(): number;
        /**
         * 更新
         */
        update(): void;
        /**
         * 遍历所有战斗对象
         * @param call 回调函数
         */
        forEachFightRole(call: (role: IFightRole) => void): void;
        /**
         * 播放动画
         * @param guid 动画guid
         * @param pos 目标位置
         */
        playAnimation(guid: string, pos: mw.Vector): any;
    }
}

declare module "odin" {
    export interface IAIState {
        /**
        * 状态进入，外部调用
        * @param context 战斗实体
        */
        enter(context: IFightRole): any;
        /**
         * 更新，外部驱动
         */
        onUpdate(): any;
        /**
         * 退出状态外部调用
         */
        exit(): any;
        /**
         * 销毁
         */
        onDestory(): any;
        /**
         * 切换状态
         * @param type 状态类型
         */
        change2State(type: number): void;
    }
}

declare module "odin" {
    export class AIMachine {
        private currentState;
        private stateMap;
        private owner;
        constructor(owner: IFightRole);
        /**
         * 注册状态
         * @param type 状态机类型
         * @param newstate 状态对象
         */
        register(type: number, newstate: IAIState): void;
        /**
        * 状态轮询：调用子状态
        */
        update(): void;
        /**
        * 切换状态：立即转换到新的状态（参数自己注册时填写）
        * @param type 新的状态
        */
        changeState(type: number): void;
        destory(): void;
    }
}

declare module "odin" {
    export abstract class AIState implements IAIState {
        protected context: IFightRole;
        protected owner: AIMachine;
        constructor(owner: AIMachine);
        /**
         * 切换状态
         * @param type 状态类型
         */
        change2State(type: number): void;
        /**
         * 状态进入，外部调用
         * @param context 战斗实体
         */
        enter(context: IFightRole): void;
        /**
         * 退出状态外部调用
         */
        exit(): void;
        /**
         * 销毁
         */
        onDestory(): void;
        /**
         * 子状态重写，enter之后触发
         */
        protected abstract onEnter(): any;
        /**
        * 子状态重写，exit之后触发
        */
        protected abstract onExit(): any;
        /**
         * 更新，外部驱动
         */
        abstract onUpdate(): any;
    }
}

declare module "odin" {
    /**
     * 输出Log
     * @param content 内容
     */
    export function oTrace(...content: any[]): void;
    /**
     * 输出Warning
     * @param content 内容
     */
    export function oTraceWarning(...content: any[]): void;
    /**
     * 输出Error
     * @param content 内容
     */
    export function oTraceError(...content: any[]): void;
    export class LogManager {
        private static _instance;
        /**net通信是否打印 */
        showNet: boolean;
        /**数据同步是否打印 */
        showSyncData: boolean;
        /**数据Action代理同步是否打印 */
        showSyncDataAction: boolean;
        private logLevel;
        private _firstWithEnable;
        private cs;
        static get instance(): LogManager;
        private constructor();
        /** 设置所有的打印是否带[ _____OdinLog_____ ]前缀*/
        set firstWithEnable(value: boolean);
        /**
         * 设置输出的等级
         * @param value 等级值(0-全部 1-Error&Warning 2-Error)
         */
        setLogLevel(value: number): void;
        /**
         * 输出Log
         * @param content 内容
         */
        log(...content: any[]): void;
        /**
         * 输出Warning
         * @param content 内容
         */
        logWarning(...content: any[]): void;
        /**
         * 输出Error
         * @param content 内容
         */
        logError(...content: any[]): void;
        /**
         * 输出带tag的Log，便于搜索
         * @param tag tag
         * @param content 内容
         */
        logWithTag(tag: string, ...content: any[]): void;
        /**
         * 输出带tag的Warning，便于搜索
         * @param tag tag
         * @param content 内容
         */
        logWarningWithTag(tag: string, ...content: any[]): void;
        /**
         * 输出带tag的Error，便于搜索
         * @param tag tag
         * @param content 内容
         */
        logErrorWithTag(tag: string, ...content: any[]): void;
        private getFirstWith;
    }
}

declare module "odin" {
    export class RPCBuilder {
        static encode(obj: any): Array<Array<any>>;
        static decode(packageData: Array<Array<any>>): any;
    }
}

declare module "odin" {
    export class OdinGame extends mw.Script {
        private extentionLog;
        private consoleLevel;
        private languageIndex;
        protected onStart(): void;
        /**所选择的语言索引(-1:系统 0:英语 1:汉语 2:日语 3:德语)*/
        protected get selectedLanguageIndex(): number;
    }
}

declare module "odin" {
    export abstract class AnalyticsUtil {
        private static readonly NET_MSG_SEND_MGS;
        private static comData;
        private static msgMap;
        /** 初始化*/
        private static init;
        /**
         * 设置公共数据，每个埋点数据都会附加的字段，由key,value的形式组织
         * @param comData 公共数据
         */
        static setCommonData(comData: any): void;
        /** 根据类型生成一个埋点数据对象
         * @param MsgClass 埋点数据类
         * @returns 数据对象
         */
        static get<T extends AnalyticsUtil>(MsgClass: TypeName<T>): T;
        /**数据说明 */
        abstract desc: string;
        /**数据体 */
        abstract data: any;
        /**
         * 上传埋点数据到潘多拉
         * @param player 在服务端调用时，指定埋点的玩家，如果不写则全房间玩家都上传
         */
        send(player?: mw.Player): void;
    }
}

declare module "odin" {
    export class OMath {
        /**
         * pingPong算法，用于计算循环，返回值在[min,max]之间
         * @param value 当前值
         * @param min 最小值
         * @param max 最大值
         * @returns 处理后，在[min,max]区间内的值
         */
        static pingPong(value: number, min: number, max: number): number;
        /**
         * 计算物理抛物线运动路径
         * @param startPos 起始位置
         * @param power 初速度向量
         * @param g 重力加速度
         * @param time 从0开始经过的时间。单位：秒
         * @param outer 用于接收结果的向量
         * @returns 结果向量
         */
        static physicsParabola(startPos: mw.Vector, power: mw.Vector, g: number, time: number, outer?: Vector): Vector;
        /**
         * 计算物理抛物线初速度
         * @param startPos 起始位置
         * @param targetPos 目标位置
         * @param g 重力加速度
         * @param totalTime 运动需要的总时间。单位：秒
         * @param outer 用于接收结果的向量
         * @returns 结果向量
         */
        static getPhysicsPower(startPos: Vector, targetPos: Vector, g: number, totalTime: number, outer?: Vector): Vector;
    }
}

declare module "odin" {
    /**
     * 随机权重组，用于权重形式的随机计算
     * @example
     * let weightGroup = new WeightGroup();
     * weightGroup.addWeight(1, 1);
     * weightGroup.addWeight(2, 2);
     * weightGroup.addWeight(3, 3);
     * weightGroup.getRandomId();//随机获取ID
     */
    export class WeightGroup {
        private weightList;
        private totalWeight;
        /**
         * 增加一个权重
         * @param id ID
         * @param weight 权重值，可以是任意数值，不用用必须0-1
         */
        addWeight(id: number, weight: number): void;
        /**
         * 获取随机权重的ID
         * @returns ID
         */
        getRandomId(): number;
        /**
         * 清空权重组
         */
        clear(): void;
    }
}
//# sourceMappingURL=index.d.ts.map
