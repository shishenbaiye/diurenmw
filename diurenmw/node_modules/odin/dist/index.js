'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

/**
 * MapEx(可序列化)
 */
exports.MapEx = void 0;
(function (MapEx) {
    /**
     * 是否为空
     * @param map
     * @returns 是/否
     */
    function isNull(map) {
        return !map || map == null || map == undefined;
    }
    MapEx.isNull = isNull;
    /**
     * 获取对象
     * @param map
     * @param key
     * @returns
     */
    function get(map, key) {
        if (map[key]) {
            return map[key];
        }
        let has = false;
        let keys = Object.keys(map);
        for (let i = 0; i < keys.length; ++i) {
            if (keys[i] == key) {
                has = true;
                break;
            }
        }
        if (has) {
            return map[key];
        }
        return null;
    }
    MapEx.get = get;
    /**
     * 设置对象
     * @param map
     * @param key
     * @param val
     */
    function set(map, key, val) {
        map[key] = val;
    }
    MapEx.set = set;
    /**
     * 删除对象
     * @param map
     * @param key
     * @returns 成功/失败
     */
    function del(map, key) {
        if (map[key]) {
            delete map[key];
            return true;
        }
        let has = false;
        let keys = Object.keys(map);
        for (let i = 0; i < keys.length; ++i) {
            if (keys[i] == key) {
                has = true;
                break;
            }
        }
        if (has) {
            delete map[key];
            return true;
        }
        return false;
    }
    MapEx.del = del;
    /**
     * 是否有指定对象
     * @param map
     * @param key
     * @returns
     */
    function has(map, key) {
        if (map[key]) {
            return true;
        }
        let has = false;
        let keys = Object.keys(map);
        for (let i = 0; i < keys.length; ++i) {
            if (keys[i] == key) {
                has = true;
                break;
            }
        }
        if (has) {
            return true;
        }
        return false;
    }
    MapEx.has = has;
    /**
     * 获取count数量
     * @param map
     * @param key
     * @returns
     */
    function count(map) {
        let res = 0;
        forEach(map, e => {
            ++res;
        });
        return res;
    }
    MapEx.count = count;
    /**
     * 遍历map
     * @param map
     * @param callback
     */
    function forEach(map, callback) {
        for (let key in map) {
            if (map[key]) {
                callback(key, map[key]);
            }
        }
    }
    MapEx.forEach = forEach;
    /**
     * 拷贝，Val还是引用出来的，只是Map换了
     * @param map
     * @returns
     */
    function copy(map) {
        let res = {};
        for (let key in map) {
            res[key] = map[key];
        }
        return res;
    }
    MapEx.copy = copy;
})(exports.MapEx || (exports.MapEx = {}));

class AIMachine {
    //当前状态
    currentState = null;
    //状态集合
    stateMap = new Map();
    //战斗对象
    owner;
    constructor(owner) {
        this.owner = owner;
    }
    /**
     * 注册状态
     * @param type 状态机类型
     * @param newstate 状态对象
     */
    register(type, newstate) {
        if (this.stateMap.has(type) == false) {
            this.stateMap.set(type, newstate);
        }
    }
    /**
    * 状态轮询：调用子状态
    */
    update() {
        if (this.currentState) {
            this.currentState.onUpdate();
        }
    }
    /**
    * 切换状态：立即转换到新的状态（参数自己注册时填写）
    * @param type 新的状态
    */
    changeState(type) {
        // 先退出当前状态
        if (this.currentState) {
            this.currentState.exit();
            this.currentState = null;
        }
        // 接着步入新状态：是否已存在了
        let state = this.stateMap.get(type);
        if (state == null) {
            return;
        }
        state.enter(this.owner);
        this.currentState = state;
    }
    destory() {
        if (this.changeState) {
            this.currentState.exit();
            this.changeState = null;
        }
        this.stateMap.forEach(state => {
            state.onDestory();
        });
        this.stateMap.clear();
        this.stateMap = null;
    }
}

class AIState {
    //战斗实体
    context;
    //状态机
    owner;
    constructor(owner) {
        this.owner = owner;
    }
    /**
     * 切换状态
     * @param type 状态类型
     */
    change2State(type) {
        this.owner.changeState(type);
    }
    /**
     * 状态进入，外部调用
     * @param context 战斗实体
     */
    enter(context) {
        this.context = context;
        this.onEnter();
    }
    /**
     * 退出状态外部调用
     */
    exit() {
        this.onExit();
    }
    /**
     * 销毁
     */
    onDestory() {
        this.context = null;
        this.owner = null;
    }
}

/**
 * 输出Log
 * @param content 内容
 */
function oTrace(...content) {
    LogManager.instance.log(...content);
}
/**
 * 输出Warning
 * @param content 内容
 */
function oTraceWarning(...content) {
    LogManager.instance.logWarning(...content);
}
/**
 * 输出Error
 * @param content 内容
 */
function oTraceError(...content) {
    LogManager.instance.logError(...content);
}
//#region Debug
class LogManager {
    static _instance;
    /**net通信是否打印 */
    showNet = true;
    /**数据同步是否打印 */
    showSyncData = true;
    /**数据Action代理同步是否打印 */
    showSyncDataAction = true;
    logLevel = 3;
    _firstWithEnable = true;
    cs;
    static get instance() {
        if (this._instance == null) {
            this._instance = new LogManager();
        }
        return this._instance;
    }
    constructor() {
        if (SystemUtil.isServer() && SystemUtil.isClient()) {
            this.cs = '';
        }
        else {
            this.cs = SystemUtil.isServer() ? "★S" : "☆C";
        }
    }
    /** 设置所有的打印是否带[ _____OdinLog_____ ]前缀*/
    set firstWithEnable(value) {
        this._firstWithEnable = value;
    }
    /**
     * 设置输出的等级
     * @param value 等级值(0-全部 1-Error&Warning 2-Error)
     */
    setLogLevel(value) {
        this.logLevel = value;
    }
    //===============基础===============
    /**
     * 输出Log
     * @param content 内容
     */
    log(...content) {
        this.logWithTag(null, ...content);
    }
    /**
     * 输出Warning
     * @param content 内容
     */
    logWarning(...content) {
        this.logWarningWithTag(null, ...content);
    }
    /**
     * 输出Error
     * @param content 内容
     */
    logError(...content) {
        this.logErrorWithTag(null, ...content);
    }
    //=============WithTag==============
    /**
     * 输出带tag的Log，便于搜索
     * @param tag tag
     * @param content 内容
     */
    logWithTag(tag, ...content) {
        if (this.logLevel > 0)
            console.log(`${this.getFirstWith(tag)}${content}`);
    }
    /**
     * 输出带tag的Warning，便于搜索
     * @param tag tag
     * @param content 内容
     */
    logWarningWithTag(tag, ...content) {
        if (this.logLevel > 1)
            console.warn(`${this.getFirstWith(tag)}${content}`);
    }
    /**
     * 输出带tag的Error，便于搜索
     * @param tag tag
     * @param content 内容
     */
    logErrorWithTag(tag, ...content) {
        if (this.logLevel > 2)
            console.error(`${this.getFirstWith(tag)}${content}`);
    }
    //===================================
    //获取前缀
    getFirstWith(tag) {
        if (this._firstWithEnable) {
            if (tag != null) {
                return `[ _____OdinLog${this.cs}][${tag}_____ ]       `;
            }
            else {
                return `[ _____OdinLog${this.cs}_____ ]       `;
            }
        }
        else {
            if (tag != null) {
                return `[${tag}]`;
            }
            else {
                return "";
            }
        }
    }
}

const NodeMsgLen = 2; //节点信息的长度
//容器类型必须1开始
const Pot_None = 1; //容器类型-无
const Pot_Array = 2; //容器类型-数组
const Pot_Map = 3; //容器类型-字典
//值类型必须0开始
const Type_Empty = 0; //无类型，容器里面没有东西，空Array或空Map
const Type_Object = 1;
const Type_Boolean = 2;
const Type_Number = 3;
const Type_String = 4;
const Type_Vector2 = 5;
const Type_Vector3 = 6;
const Type_Vector4 = 7;
class RPCBuilder {
    static encode(obj) {
        return RPCEncode.encode(obj);
    }
    static decode(packageData) {
        return RPCDecode.decode(packageData);
    }
}
class RPCEncode {
    static TypeStr_Boolean = "boolean";
    static TypeStr_Number = "number";
    static TypeStr_String = "string";
    //2个number代表一个节点： 参数1:(容器类型|数据类型|key索引)   父节点索引(-1是根节点)   数据起始索引   数据长度
    //类型的位数分布：00|00|000       9999|999|999
    //容器类型：0-无 1-数组 2-字典
    //最多支持999个key
    static nodeMsg = [];
    static keyArr = [];
    static keyIndexMap = new Map();
    static boolValues = [];
    static numValues = [];
    static strValues = [];
    static v2Values = [];
    static v3Values = [];
    static v4Values = [];
    static packageBuffer = [null, null, null, null, null, null, null, null]; //nodeMsg[], key[], bool[], number[], string[], v2[], v3[], v4[]
    static encode(obj) {
        this.clearPackageBuffer();
        this.encodeHandle(obj, null, -1);
        this.packageBuffer[0] = this.nodeMsg;
        this.packageBuffer[1] = this.keyArr;
        this.packageBuffer[2] = this.boolValues.length > 0 ? this.boolValues : null;
        this.packageBuffer[3] = this.numValues.length > 0 ? this.numValues : null;
        this.packageBuffer[4] = this.strValues.length > 0 ? this.strValues : null;
        this.packageBuffer[5] = this.v2Values.length > 0 ? this.v2Values : null;
        this.packageBuffer[6] = this.v3Values.length > 0 ? this.v3Values : null;
        this.packageBuffer[7] = this.v4Values.length > 0 ? this.v4Values : null;
        return this.packageBuffer;
    }
    static v3 = new Vector();
    static encodeNodeMsgParam1(potType, valueType, nodeName) {
        return potType * 100000 + valueType * 1000 + (this.getKeyIndex(nodeName) + 1); //将key索引从-1开始转为0开始，所以需要+1
    }
    static decodeNodeMsgParam1(msgNum) {
        let potType = Math.floor(msgNum / 100000); //容器类型
        msgNum %= 100000;
        let valueType = Math.floor(msgNum / 1000); //值类型
        let keyIndex = msgNum % 1000 - 1; //0代表无效 有效值从1开始 所以要-1
        this.v3.x = potType;
        this.v3.y = valueType;
        this.v3.z = keyIndex;
        return this.v3;
    }
    static encodeNodeMsgParam2(parentNodeIndex, valueIndex, valueLen) {
        return 1000000 * parentNodeIndex + 1000 * valueIndex + valueLen;
    }
    static decodeNodeMsgParam2(msgNum) {
        let parentNodeIndex = Math.floor(msgNum / 1000000) - 1; //0开始 转为-1开始 -1表示没有依赖 也就是根节点
        msgNum %= 1000000;
        let valueIndex = Math.floor(msgNum / 1000);
        let valueLen = msgNum % 1000;
        this.v3.x = parentNodeIndex;
        this.v3.y = valueIndex;
        this.v3.z = valueLen;
        return this.v3;
    }
    //获取key在key池中的索引 -1代表无效
    static getKeyIndex(key) {
        //获取key在key池中的索引 1开始 0代表无效key
        if (key == null)
            return -1;
        if (!this.keyIndexMap.has(key)) {
            this.keyIndexMap.set(key, this.keyArr.length);
            this.keyArr.push(key);
        }
        return this.keyIndexMap.get(key);
    }
    static encodeHandle(node, nodeName, parentNodeIndex, potType = null, valueType = null) {
        parentNodeIndex++; //-1开始 转成0开始
        if (potType == null)
            potType = this.getPotType(node);
        if (valueType == null)
            valueType = this.getValueType(node, potType);
        switch (potType) {
            case Pot_Array: //Array容器
                switch (valueType) {
                    case Type_Object: //对象Array
                        let curNodeIndex = this.nodeMsg.length / NodeMsgLen; //当前节点的索引，用于传给子节点做父节点
                        this.nodeMsg.push(this.encodeNodeMsgParam1(potType, valueType, nodeName), this.encodeNodeMsgParam2(parentNodeIndex, 0, 0));
                        for (let i = 0; i < node.length; i++) {
                            this.encodeHandle(node[i], null, curNodeIndex);
                        }
                        break;
                    case Type_Empty: //空Array
                        this.nodeMsg.push(this.encodeNodeMsgParam1(potType, valueType, nodeName), this.encodeNodeMsgParam2(parentNodeIndex, 0, 0));
                        break;
                    default: //基础类型Array
                        let saveToArr = this.getSaveValueArr(valueType);
                        this.nodeMsg.push(this.encodeNodeMsgParam1(potType, valueType, nodeName), this.encodeNodeMsgParam2(parentNodeIndex, saveToArr.length, node.length));
                        saveToArr.push(...node);
                        break;
                }
                break;
            case Pot_Map: //Map容器
                let curNodeIndex;
                switch (valueType) {
                    case Type_Object: //value是对象
                        curNodeIndex = this.nodeMsg.length / NodeMsgLen;
                        this.nodeMsg.push(this.encodeNodeMsgParam1(potType, valueType, nodeName), this.encodeNodeMsgParam2(parentNodeIndex, 0, 0));
                        for (let [key, value] of node) {
                            this.encodeHandle(value, key, curNodeIndex);
                        }
                        break;
                    case Type_Empty: //空Map
                        this.nodeMsg.push(this.encodeNodeMsgParam1(potType, valueType, nodeName), this.encodeNodeMsgParam2(parentNodeIndex, 0, 0));
                        break;
                    default: //value是基础类型
                        curNodeIndex = this.nodeMsg.length / NodeMsgLen;
                        this.nodeMsg.push(this.encodeNodeMsgParam1(potType, valueType, nodeName), this.encodeNodeMsgParam2(parentNodeIndex, 0, 0));
                        for (let [key, value] of node) {
                            this.encodeHandle(value, key, curNodeIndex, Pot_None, valueType);
                        }
                        break;
                }
                break;
            default: //无容器
                if (valueType == Type_Object) { //一个复杂类型
                    let curNodeIndex = this.nodeMsg.length / NodeMsgLen;
                    this.nodeMsg.push(this.encodeNodeMsgParam1(potType, valueType, nodeName), this.encodeNodeMsgParam2(parentNodeIndex, 0, 0));
                    for (let key in node) {
                        this.encodeHandle(node[key], key, curNodeIndex);
                    }
                }
                else { //一个简单类型
                    let saveToArr = this.getSaveValueArr(valueType);
                    this.nodeMsg.push(this.encodeNodeMsgParam1(potType, valueType, nodeName), this.encodeNodeMsgParam2(parentNodeIndex, saveToArr.length, 1));
                    saveToArr.push(node);
                }
                break;
        }
    }
    //获取容器的类型
    static getPotType(node) {
        if (node instanceof Array)
            return Pot_Array;
        if (node instanceof Map)
            return Pot_Map;
        return Pot_None;
    }
    //获取值的类型
    static getValueType(node, potType) {
        switch (potType) {
            case Pot_Array:
                if (node.length == 0)
                    return Type_Empty;
                node = node[0];
                break;
            case Pot_Map:
                if (node.size == 0)
                    return Type_Empty;
                node = node.values().next().value;
                break;
        }
        switch (typeof node) {
            case this.TypeStr_Boolean: return Type_Boolean;
            case this.TypeStr_Number: return Type_Number;
            case this.TypeStr_String: return Type_String;
            default:
                if (node instanceof Vector) {
                    return Type_Vector3;
                }
                else if (node instanceof Vector2) {
                    return Type_Vector2;
                }
                else if (node instanceof Vector4) {
                    return Type_Vector4;
                }
                else {
                    return Type_Object; //Array | Map | Object
                }
        }
    }
    static getSaveValueArr(valueType) {
        switch (valueType) {
            case Type_Boolean: return this.boolValues;
            case Type_Number: return this.numValues;
            case Type_String: return this.strValues;
            case Type_Vector2: return this.v2Values;
            case Type_Vector3: return this.v3Values;
            case Type_Vector4: return this.v4Values;
        }
    }
    //清理所有的缓存容器
    static clearPackageBuffer() {
        this.keyArr.length = 0;
        this.keyIndexMap.clear();
        this.nodeMsg.length = 0;
        this.boolValues.length = 0;
        this.numValues.length = 0;
        this.strValues.length = 0;
    }
}
//==============================================================================================================================================
class RPCDecode {
    static nodeObjs = [];
    static decode(packageBuffer) {
        this.nodeObjs.length = 0;
        const nodes = packageBuffer[0];
        const keys = packageBuffer[1];
        for (let i = 0; i < nodes.length; i += NodeMsgLen) {
            //解析第一个节点参数
            let v3 = RPCEncode.decodeNodeMsgParam1(nodes[i]);
            const potType = v3.x; //容器类型
            const valueType = v3.y; //数据类型
            const keyIndex = v3.z; //key索引 -1无效
            //解析第二个节点参数
            v3 = RPCEncode.decodeNodeMsgParam2(nodes[i + 1]);
            const parentNodeIndex = v3.x; //0开始 转为-1开始 -1表示没有依赖 也就是根节点
            const valueIndex = v3.y; //数据索引
            const valueLen = v3.z; //数据长度
            let nodeObj = null;
            switch (potType) {
                case Pot_Array:
                    if (valueType == Type_Object || valueType == Type_Empty) { //复杂数据类型 Array | Map | Object
                        nodeObj = [];
                    }
                    else {
                        nodeObj = this.getValueArr(packageBuffer, valueType).slice(valueIndex, valueIndex + valueLen);
                    }
                    break;
                case Pot_Map:
                    nodeObj = new Map();
                    break;
                default:
                    if (valueType == Type_Object) {
                        nodeObj = {};
                    }
                    else {
                        nodeObj = this.getValueArr(packageBuffer, valueType)[valueIndex];
                    }
                    break;
            }
            if (parentNodeIndex != -1) {
                const parentPotType = RPCEncode.decodeNodeMsgParam1(nodes[parentNodeIndex * NodeMsgLen]).x;
                const key = keyIndex == -1 ? null : keys[keyIndex];
                switch (parentPotType) {
                    case Pot_Array:
                        this.nodeObjs[parentNodeIndex].push(nodeObj);
                        break;
                    case Pot_Map:
                        this.nodeObjs[parentNodeIndex].set(key, nodeObj);
                        break;
                    default:
                        this.nodeObjs[parentNodeIndex][key] = nodeObj;
                        break;
                }
            }
            this.nodeObjs.push(nodeObj);
        }
        return this.nodeObjs[0];
    }
    static getValueArr(packageBuffer, valueType) {
        switch (valueType) {
            case Type_Boolean: return packageBuffer[2];
            case Type_Number: return packageBuffer[3];
            case Type_String: return packageBuffer[4];
            case Type_Vector2: return packageBuffer[5];
            case Type_Vector3: return packageBuffer[6];
            case Type_Vector4: return packageBuffer[7];
        }
    }
}

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};

class OdinGame extends mw.Script {
    extentionLog = false;
    consoleLevel = "3";
    languageIndex = "-1";
    onStart() {
        LogManager.instance.setLogLevel(Number(this.consoleLevel));
        oTrace("OdinGame Script onStart");
        //type:1-Log 2-Warning 3-Error content:内容
        if (this.extentionLog) {
            mwext["GameInitializer"]["openLog"]((type, content) => {
                switch (type) {
                    case 1:
                        oTrace(content);
                        break;
                    case 2:
                        oTraceWarning(content);
                        break;
                    case 3:
                        oTraceError(content);
                        break;
                }
            }, true, true);
        }
    }
    /**所选择的语言索引(-1:系统 0:英语 1:汉语 2:日语 3:德语)*/
    get selectedLanguageIndex() {
        return Number(this.languageIndex);
    }
}
__decorate([
    mw.Property({ displayName: "打印extention的Log", group: "Odin设置" })
], OdinGame.prototype, "extentionLog", void 0);
__decorate([
    mw.Property({ displayName: "Log级别", group: "Odin设置", selectOptions: { "不打印": "0", "Error": "1", "Warn": "2", "Log": "3" } }) //0-3 0:不输出 3:输出所有
], OdinGame.prototype, "consoleLevel", void 0);
__decorate([
    mw.Property({ displayName: "语言类型", group: "Odin设置", selectOptions: { "系统默认": "-1", "English": "0", "简体中文": "1", "日本語": "2", "Deutsch": "3" } })
], OdinGame.prototype, "languageIndex", void 0);

var AnalyticsUtil_1;
/*
 * @Author: xicun.kang xicun.kang@appshahe.com
 * @Date: 2023-08-07 18:22:22
 * @LastEditors: xicun.kang xicun.kang@appshahe.com
 * @LastEditTime: 2023-08-07 18:38:02
 * @FilePath: \odinframework_new\JavaScripts\odin\utils\AnalyticsUtil.ts
 * @Description: 这是默认设置,请设置`customMade`, 打开koroFileHeader查看配置 进行设置: https://github.com/OBKoro1/koro1FileHeader/wiki/%E9%85%8D%E7%BD%AE
 */
//埋点工具
exports.AnalyticsUtil = AnalyticsUtil_1 = class AnalyticsUtil {
    static NET_MSG_SEND_MGS = "NET_MSG_SEND_MGS";
    static comData; //通用数据
    static msgMap;
    /** 初始化*/
    static init() {
        if (this.msgMap != null)
            return;
        this.msgMap = new Map();
        if (SystemUtil.isClient()) {
            mw.Event.addServerListener(AnalyticsUtil_1.NET_MSG_SEND_MGS, (eventName, eventDesc, jsonData) => {
                mw.RoomService.reportLogInfo(eventName, eventDesc, jsonData);
            });
        }
    }
    /**
     * 设置公共数据，每个埋点数据都会附加的字段，由key,value的形式组织
     * @param comData 公共数据
     */
    static setCommonData(comData) {
        AnalyticsUtil_1.comData = comData;
    }
    /** 根据类型生成一个埋点数据对象
     * @param MsgClass 埋点数据类
     * @returns 数据对象
     */
    static get(MsgClass) {
        if (this.msgMap == null) {
            this.init();
        }
        if (!AnalyticsUtil_1.msgMap.has(MsgClass.name)) {
            let msg = new MsgClass();
            msg.data = {};
            if (!AnalyticsUtil_1.comData) {
                for (const key in AnalyticsUtil_1.comData) {
                    msg[key] = AnalyticsUtil_1.comData[key];
                }
            }
            AnalyticsUtil_1.msgMap.set(MsgClass.name, msg);
        }
        return AnalyticsUtil_1.msgMap.get(MsgClass.name);
    }
    /**
     * 上传埋点数据到潘多拉
     * @param player 在服务端调用时，指定埋点的玩家，如果不写则全房间玩家都上传
     */
    send(player) {
        let eventName = this.constructor.name.toLowerCase();
        if (eventName.endsWith("$1")) {
            eventName = eventName.substring(0, eventName.length - 2);
        }
        let eventDesc = this.desc;
        let jsonData = {};
        for (const key in this.data) { //潘多拉要求key都要是小写的，value不做要求
            jsonData[key.toLowerCase()] = this.data[key];
        }
        let jsonStr = JSON.stringify(jsonData);
        if (SystemUtil.isClient()) {
            mw.RoomService.reportLogInfo(eventName, eventDesc, jsonStr);
        }
        else {
            if (player == null) {
                mw.Event.dispatchToAllClient(AnalyticsUtil_1.NET_MSG_SEND_MGS, eventName, eventDesc, jsonStr);
            }
            else {
                mw.Event.dispatchToClient(player, AnalyticsUtil_1.NET_MSG_SEND_MGS, eventName, eventDesc, jsonStr);
            }
        }
    }
};
exports.AnalyticsUtil = AnalyticsUtil_1 = __decorate([
    Decorator.autoExecute("init")
], exports.AnalyticsUtil);
//埋点例子
// //定义一个埋点消息类
// class TS_PlayerFirstLogin extends AnalyticsUtil {
//     desc: string = '第一次登录';
//     data: { loginTime: number };
// }
// // //发送一个埋点
// let msg = AnalyticsUtil.get(TS_PlayerFirstLogin);//生成一个埋点
// msg.data.loginTime = 100;//设置字段值
// msg.send();//发送埋点

class OMath {
    /**
     * pingPong算法，用于计算循环，返回值在[min,max]之间
     * @param value 当前值
     * @param min 最小值
     * @param max 最大值
     * @returns 处理后，在[min,max]区间内的值
     */
    static pingPong(value, min, max) {
        let range = max - min;
        let result = value % (range * 2);
        if (result < range) {
            return result + min;
        }
        else {
            return range * 2 - result + min;
        }
    }
    /**
     * 计算物理抛物线运动路径
     * @param startPos 起始位置
     * @param power 初速度向量
     * @param g 重力加速度
     * @param time 从0开始经过的时间。单位：秒
     * @param outer 用于接收结果的向量
     * @returns 结果向量
     */
    static physicsParabola(startPos, power, g, time, outer) {
        const result = outer || new Vector();
        result.x = startPos.x + power.x * time;
        result.y = startPos.y + power.y * time;
        result.z = startPos.z + power.z * time - 0.5 * g * time * time;
        return result;
    }
    /**
     * 计算物理抛物线初速度
     * @param startPos 起始位置
     * @param targetPos 目标位置
     * @param g 重力加速度
     * @param totalTime 运动需要的总时间。单位：秒
     * @param outer 用于接收结果的向量
     * @returns 结果向量
     */
    static getPhysicsPower(startPos, targetPos, g, totalTime, outer) {
        const power = outer || new Vector();
        const v3 = Vector.subtract(targetPos, startPos);
        power.x = v3.x / totalTime;
        power.y = v3.y / totalTime;
        power.z = v3.z / totalTime + totalTime * 0.5 * g;
        return power;
    }
}

/**
 * 随机权重组，用于权重形式的随机计算
 * @example
 * let weightGroup = new WeightGroup();
 * weightGroup.addWeight(1, 1);
 * weightGroup.addWeight(2, 2);
 * weightGroup.addWeight(3, 3);
 * weightGroup.getRandomId();//随机获取ID
 */
class WeightGroup {
    weightList = [];
    totalWeight = 0;
    /**
     * 增加一个权重
     * @param id ID
     * @param weight 权重值，可以是任意数值，不用用必须0-1
     */
    addWeight(id, weight) {
        this.weightList.push(new Vector(id, this.totalWeight, this.totalWeight + weight));
        this.totalWeight += weight;
    }
    /**
     * 获取随机权重的ID
     * @returns ID
     */
    getRandomId() {
        let weight = Math.random() * this.totalWeight;
        for (let i = 0; i < this.weightList.length; i++) {
            let v = this.weightList[i];
            if (weight >= v.y && weight < v.z) {
                return v.x;
            }
        }
        return 0;
    }
    /**
     * 清空权重组
     */
    clear() {
        this.weightList.length = 0;
        this.totalWeight = 0;
    }
}

exports.AIMachine = AIMachine;
exports.AIState = AIState;
exports.LogManager = LogManager;
exports.OMath = OMath;
exports.OdinGame = OdinGame;
exports.RPCBuilder = RPCBuilder;
exports.WeightGroup = WeightGroup;
exports.oTrace = oTrace;
exports.oTraceError = oTraceError;
exports.oTraceWarning = oTraceWarning;
//# sourceMappingURL=index.js.map
